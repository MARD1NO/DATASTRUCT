# 散列表

散列表又叫 **哈希表**，基于通过散列函数对元素散列获取对应的 **键值**
散列函数也叫 **哈希函数**，散列函数计算出来的值叫散列值



## 散列函数的设计要求

1. 散列函数计算得到的散列值是一个非负整数；
2. 如果 key1 = key2，那 hash(key1) == hash(key2)；
3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)



但是在真实情况下，第三点是无法满足的，我们无法找到一个完美的散列函数，任何散列函数都有可能产生 **哈希冲突**因此我们需要通过其他途径解决



## 散列冲突

### 1. 开放寻址法 

核心思想是如果当前位置冲突了，就继续找下一个

最简单的就是 **线性探测**

![image-20200303182825107](C:\Users\35952\AppData\Roaming\Typora\typora-user-images\image-20200303182825107.png)

如果当前位置被占用，则依次往后查找

### 散列表查找元素

首先我们通过散列函数求出 要查找的元素的散列值，然后在散列表里根据该键值查找，如果元素不等，则继续往下查找。若仍没找到，说明该元素不在散列表当中

### 散列表删除元素

删除元素我们 **不能简单地将当前数组元素置空**

我们有这样一个情况

一个大小为5的数组，分别存放 None None 23 3 None

我们如果使用的是置空的方法删除23 那么数组变为 None None None 3 None

此时我们再查找3的时候，我们经过哈希找数组第三个元素，显示为None，但其实我们3是存在于数组当中的



导致查找方法失效的原因是 将元素置空后 **破坏了哈希冲突的规律**

因此我们需要在删除的元素那里 **放置一个deleted标记**

### 其他开放寻址法

还有其他变种比如二次探测法，双重散列法

线性探测每次探测步长为1

而二次探测的探测步长就是0 ,1^2 ,2^2, 3^2, 4^2



双重散列法就是使用 **一组哈希函数**
如果当前位置已占用，则使用另外一个哈希函数进行散列，以此类推

### 装载因子

不论使用哪种方法，**随着数组中元素增加，产生冲突的几率也就越大**

因此我们需要保持数组中存留部分空槽

我们定义了一个装载因子:  **表中元素个数 / 散列表长度**

装载因子越大，说明空闲位置越少

装载因子越嚣，说明空闲位置越多

## 链表法

链表法是更常用的方法，它在产生冲突的区域连成一个链表

具有相同散列值的元素都会连接到链表尾部

![image-20200303184016854](C:\Users\35952\AppData\Roaming\Typora\typora-user-images\image-20200303184016854.png)

![image-20200303184037418](C:\Users\35952\AppData\Roaming\Typora\typora-user-images\image-20200303184037418.png)

